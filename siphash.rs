// Rust implementation of the Siphash-2-4 PRF
// For more info on Siphash: http://131002.net/siphash
#[link(name = "siphash", author = "dgryski", vers = "0.1")];

use std;

trait siphash {
    fn input(~[u8]);
    fn input_str(~str);
    fn result() -> ~[u8];
    fn result_str() -> ~str;
    fn reset();
}

fn siphash(key0 : u64, key1 : u64) -> siphash {
    type sipstate = {
        k0 : u64,
        k1 : u64,
        mut length : uint, // how many bytes we've processed
        mut v0 : u64, // state
        mut v1 : u64,
        mut v2 : u64,
        mut v3 : u64,
        tail : ~[mut u8]/8, // unprocessed bytes
        mut ntail : uint, //  how many bytes in tail are valid
    };

    fn add_input(st : sipstate, msg : ~[u8]) {
        let length = vec::len(msg);
        st.length += length;

        let mut needed = 0u;

        if st.ntail != 0 {
            needed = 8 - st.ntail;

            if length < needed {

                let mut t = 0;
                while t < length {
                    st.tail[st.ntail+t] = msg[t];
                    t += 1;
                }
                st.ntail += length;

                return;
            }

            let mut t = 0;
            while t < needed {
                st.tail[st.ntail+t] = msg[t];
                t += 1;
            }
            st.ntail += needed;

            let m = (st.tail[0] as u64 <<  0) |
                (st.tail[1] as u64 <<  8) |
                (st.tail[2] as u64 << 16) |
                (st.tail[3] as u64 << 24) |
                (st.tail[4] as u64 << 32) |
                (st.tail[5] as u64 << 40) |
                (st.tail[6] as u64 << 48) |
                (st.tail[7] as u64 << 56);

            st.v3 ^= m;
            sipround(st.v0, st.v1, st.v2, st.v3);
            sipround(st.v0, st.v1, st.v2, st.v3);
            st.v0 ^= m;

            st.ntail = 0;
        }

        let mlen = vec::len(msg) - needed;
        let rem = mlen & 7;
        let maxoffs = mlen - rem;

        let mut offs = needed;
        while offs < maxoffs {

            let mi = load_u64(msg, offs);

            st.v3 ^= mi;
            sipround(st.v0, st.v1, st.v2, st.v3);
            sipround(st.v0, st.v1, st.v2, st.v3);
            st.v0 ^= mi;

            offs += 8;
        }

        let mut t = 0u;
        while t < rem {
            st.tail[t] = msg[offs+t];
            t += 1
        }
        st.ntail = rem
    }

    fn mk_result(st : sipstate) -> ~[u8] {

        let mut v0 = st.v0;
        let mut v1 = st.v1;
        let mut v2 = st.v2;
        let mut v3 = st.v3;

        let mut mfinal = (st.length as u64 % 256) << 56;

        if  7u <= st.ntail { mfinal |= (st.tail[ 6u] as u64) << 48u }
        if  6u <= st.ntail { mfinal |= (st.tail[ 5u] as u64) << 40u }
        if  5u <= st.ntail { mfinal |= (st.tail[ 4u] as u64) << 32u }
        if  4u <= st.ntail { mfinal |= (st.tail[ 3u] as u64) << 24u }
        if  3u <= st.ntail { mfinal |= (st.tail[ 2u] as u64) << 16u }
        if  2u <= st.ntail { mfinal |= (st.tail[ 1u] as u64) <<  8u }
        if  1u <= st.ntail { mfinal |= (st.tail[ 0u] as u64) <<  0u }

        v3 ^= mfinal;

        sipround(v0, v1, v2, v3);
        sipround(v0, v1, v2, v3);

        v0 ^= mfinal;

        // finalize

        v2 ^= 0xff;

        sipround(v0, v1, v2, v3);
        sipround(v0, v1, v2, v3);
        sipround(v0, v1, v2, v3);
        sipround(v0, v1, v2, v3);

        let h = v0 ^ v1 ^ v2 ^ v3;

        return ~[
            (h >> 0) as u8,
            (h >> 8) as u8,
            (h >> 16) as u8,
            (h >> 24) as u8,
            (h >> 32) as u8,
            (h >> 40) as u8,
            (h >> 48) as u8,
            (h >> 56) as u8,
        ];
    }

   impl sipstate : siphash {
        fn reset() {
            self.length = 0;
            self.v0 = self.k0 ^ 0x736f6d6570736575;
            self.v1 = self.k1 ^ 0x646f72616e646f6d;
            self.v2 = self.k0 ^ 0x6c7967656e657261;
            self.v3 = self.k1 ^ 0x7465646279746573;
            self.ntail = 0;
        }
        fn input(msg: ~[u8]) { add_input(self, msg); }
        fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }
        fn result() -> ~[u8] { return mk_result(self); }
        fn result_str() -> ~str {
            let r = mk_result(self);
            let mut s = ~"";
            for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }
            return s;
        }
    }

    let st = {
        k0 : key0,
        k1 : key1,
        mut length : 0u,
        mut v0 : key0 ^ 0x736f6d6570736575,
        mut v1 : key1 ^ 0x646f72616e646f6d,
        mut v2 : key0 ^ 0x6c7967656e657261,
        mut v3 : key1 ^ 0x7465646279746573,
        tail : ~[mut 0u8,0,0,0,0,0,0,0]/8,
        mut ntail : 0u,
    };

    let sh = st as siphash;
    sh.reset();
    return sh;
}

#[inline(always)]
fn rotl(x : u64, b : uint) -> u64 { ((x) << (b)) | ((x) >> (64 - (b))) }

#[inline(always)]
fn load_u64(b : &[u8], i : uint) -> u64 {
    (b[0+i] as u64 <<  0) |
    (b[1+i] as u64 <<  8) |
    (b[2+i] as u64 << 16) |
    (b[3+i] as u64 << 24) |
    (b[4+i] as u64 << 32) |
    (b[5+i] as u64 << 40) |
    (b[6+i] as u64 << 48) |
    (b[7+i] as u64 << 56)
}

#[inline(always)]
fn sipround(&v0 : u64, &v1 : u64, &v2 : u64, &v3 : u64) {
        v0 = v0 + v1; v1=rotl(v1,13); v1 ^= v0; v0=rotl(v0,32);
        v2 = v2 + v3; v3=rotl(v3,16); v3 ^= v2;
        v0 += v3; v3=rotl(v3,21); v3 ^= v0;
        v2 += v1; v1=rotl(v1,17); v1 ^= v2; v2=rotl(v2,32);
}

#[test]
fn test_siphash() {
    // test vectors from reference implementation: http://131002.net/siphash/siphash24.c
    let vecs : ~[~[u8]] = ~[
        ~[ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],
        ~[ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],
        ~[ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],
        ~[ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],
        ~[ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],
        ~[ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],
        ~[ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],
        ~[ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],
        ~[ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],
        ~[ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],
        ~[ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],
        ~[ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],
        ~[ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],
        ~[ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],
        ~[ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],
        ~[ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],
        ~[ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],
        ~[ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],
        ~[ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],
        ~[ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],
        ~[ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],
        ~[ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],
        ~[ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],
        ~[ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],
        ~[ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],
        ~[ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],
        ~[ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],
        ~[ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],
        ~[ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],
        ~[ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],
        ~[ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],
        ~[ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],
        ~[ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],
        ~[ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],
        ~[ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],
        ~[ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],
        ~[ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],
        ~[ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],
        ~[ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],
        ~[ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],
        ~[ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],
        ~[ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],
        ~[ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],
        ~[ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],
        ~[ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],
        ~[ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],
        ~[ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],
        ~[ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],
        ~[ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],
        ~[ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],
        ~[ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],
        ~[ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],
        ~[ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],
        ~[ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],
        ~[ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],
        ~[ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],
        ~[ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],
        ~[ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],
        ~[ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],
        ~[ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],
        ~[ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],
        ~[ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],
        ~[ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],
        ~[ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]
    ];

    fn to_hex_str(v : ~[u8]) -> ~str {
        let mut s = ~"";
        for vec::each(v) |b| { s += uint::to_str(b as uint, 16u); }
        return s;
    }

    let k0 = 0x0706050403020100u64;
    let k1 = 0x0f0e0d0c0b0a0908u64;
    let stream_inc = siphash(k0,k1);
    let stream_full = siphash(k0,k1);

    let mut buf : ~[u8] = ~[];
    let mut t = 0;

    while t < 64 {
        stream_full.reset();
        stream_full.input(buf);
        let f = stream_full.result_str();
        let i = stream_inc.result_str();
        let v = to_hex_str(vecs[t]);
        // io::println(#fmt["%d: (%s) => inc=%s full=%s", t, to_hex_str(vecs[t]), i, f]);

        assert f == i && v == f;

        buf += ~[t as u8];
        stream_inc.input(~[t as u8]);

        t += 1;
    }
}
